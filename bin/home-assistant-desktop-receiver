#!/bin/env python3
import http.server
import socketserver
from urllib import parse
import dbus
import cgi
import json



PORT = 8124

#rather than just basing it off lock state, assume we're not active if unused for n minutes
#set to 0 to disable
IDLE_TIMEOUT = 1 #in minutes

IDLE_TIMEOUT_MS = IDLE_TIMEOUT * 60 * 1000

session_bus = dbus.SessionBus()

class HomeAssistantIntegrator(http.server.BaseHTTPRequestHandler):
    def reply(s, value):
        s.send_response(200)
        s.send_header("Content-type", "text/plain")
        s.end_headers()
        response = b"0"
        if value:
            response = b"1"
        s.wfile.write(response)

    def _set_headers(s):
        s.send_response(200)
        s.send_header('Content-type', 'application/json')
        s.end_headers()

    def error(s):
        s.send_response(403)
        s.end_headers()

    def do_GET(s):
        url = parse.urlparse(s.path)
        endpoint = url.path
        print(endpoint)
        query = parse.parse_qs(url.query)
        if endpoint == "/notifications":
            message = query["message"][0]
            print(message)
            try:
                notify_obj = session_bus.get_object("org.freedesktop.Notifications", "/org/freedesktop/Notifications")
                notify_obj.Notify(
                    "homeassistant", #app name
                    0, #replaces (0 = not relevant)
                    "", #icon name / path
                    "Home Assistant", # title
                    message, # body
                    [], # actions
                    {}, #hints
                    0, #timeout. 0 = indefinite
                    dbus_interface="org.freedesktop.Notifications")
                s.reply(True)
            except:
                s.reply(False)
                print("Could not send notification")
        elif endpoint == "/isActive":
            is_active = True # we received the message, we're half alive at least

            #test if screen saver is active, if so we're definitely inactive
            #if not, see if we've been idle for longer than the timeout
            try:
                screensaver = session_bus.get_object("org.freedesktop.ScreenSaver", "/org/freedesktop/ScreenSaver")
                is_active = not screensaver.GetActive() # negated, as we're active if the screensaver isn't
                if is_active and IDLE_TIMEOUT_MS > 0:
                    print ("Checking idle time %d %d" % (screensaver.GetSessionIdleTime() ,IDLE_TIMEOUT_MS))
                    is_active = screensaver.GetSessionIdleTime() < IDLE_TIMEOUT_MS

            except:
                print("Could not determine session state. Assuming active")
            s.reply(is_active)

        else:
            s.error()

    # POST echoes the message adding a JSON field
    def do_POST(s):
        #ctype, pdict = cgi.parse_header(s.headers.getheader('content-type'))
        #fix python3https://stackoverflow.com/questions/31486618/cgi-parse-multipart-function-throws-typeerror-in-python-3
        c_type, p_dict = cgi.parse_header(s.headers.get('Content-Type'))
        
        # refuse to receive non-json content
        if c_type != 'application/json':
            s.send_response(400)
            s.end_headers()
            return
            
        # read the message and convert it into a python dictionary
        #length = int(s.headers.getheader('content-length'))
        #fix python3
        length = int(s.headers.get('content-length'))
        message = json.loads(s.rfile.read(length))
        title = json.loads(s.rfile.read(length))
        print(message)
        print(title)
        #print(json.loads(s.rfile.read(length)))
        
        # add a property to the object, just to mess with data
        #message['received'] = 'ok'
        
        # send the message back
        #s._set_headers()
        #s.wfile.write(json.dumps(message))

if __name__ == '__main__':
    httpd = socketserver.TCPServer(("", PORT), HomeAssistantIntegrator)
    print("serving at port", PORT)
    httpd.serve_forever()

